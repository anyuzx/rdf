import sys
from math import *
import rdf
import numpy as np
import matplotlib.pyplot as plt
from time import strftime
import os.path

######################################################
#                          V * h_ab(n)               #
#   g_ab(r_n)=------------------------------------   #
#             2*pi*N_a*N_b*(n-1/2)^2*(dr)^3*N_conf   #
#                                                    #      
#     calculate the Radial Distribution Function     #
#     from the HISTORY file generated by DL POLY     #
#          author:Guang Shi    05.19.2014            #
#                                                    #
######################################################

################################
# update log
# 06.07.2014
# correct an error in the previous version. The volume in NPT ensemble is not constant. Need to read the volume at every configuration

################################
# declare the variables

# declare the directory of DL_POLY HISTORY file

#filedirectory="/Users/Shi/Dropbox/guangshi/simulation/symmetry/NPT_ewald/trial3/"
filedirectory="/Volumes/Data/guangshi/simulation/symmetry//NPT_ewald/trial4/"

trajfilenam = 'HISTORY'
inffilenam = 'README'


natm_molecule = 5    # declare the number of atoms in one molecule
ni = 0               # indicates the number of line where each configuration starts
count = 1            # for loop in many configurations
countMax = 1000      # the number of configurations considered
nHist = 500          # number of bins
rHistMax = 10.       # upper limit for considered interatomic distance. 
                     # This must be less than half of size of the simulation box(periodic condition) 

binsize = rHistMax/nHist                                           # calculate the width of bin
bin = np.array(list((i+0.5)*binsize for i in range(nHist)))      # declare the bin list

RDFhist = np.array(list(0.0 for i in range(nHist)))                # declare the Radial Distribution Function histogram list

RDF = {}                                                # declare a dictionary whose keys are different pairs of atoms and
                                                        # values are the corresponding RDF histogram: RDFhist defined above

atmnam_natm_list = {}                                   # declare a dictionary whose keys are atom names and values are the number of atoms in one molecule

#finish declaring the variables
###############################


# define the volume calculation function.
# inputs are the "imcon" key word which is used in DL POLY program
# x,y,z are the simulation box vector
# for details, refer to DL_POLY 2 USER MANUAL 
def calvolume(imcon,x,y,z):
    if imcon == 1 or imcon == 2 or imcon == 3:
        v = z[0]*(x[1]*y[2]-x[2]*y[1])+z[1]*(x[2]*y[0]-x[0]*y[2])+z[2]*(x[0]*y[1]-x[1]*y[0])
        return v,1
    elif imcon == 4 or imcon == 5 or imcon == 7:
        v = z[0]*(x[1]*y[2]-x[2]*y[1])+z[1]*(x[2]*y[0]-x[0]*y[2])+z[2]*(x[0]*y[1]-x[1]*y[0])
        return v/2.0,1
    else:
        return 0,0

###############################
# read the CONTROL file Header

if os.path.isfile(filedirectory+inffilenam):
    with open(filedirectory + inffilenam,'r') as f:
        contr_header = f.readline()
else:
    print "README file doesn't exist. Please check the directory or create a README file"
    sys.exit()
###############################    

# Calculate the volume of simulation box
# open the file---> read line by line---> at second line, record the key variable "keytrj" and "imcon"
# read the simulation box size. store it to a vector: boxvector
with open(filedirectory + trajfilenam,'r') as f:
    boxvector = []
    for i, line in enumerate(f):
        if i == 1:
            keytrj = int(line.split()[0])
            imcon = int(line.split()[1])
            if imcon == 0:
                print "ERROR: No periodic boundary condition is applied. Program is terminated"
                sys.exit()
            elif imcon == 6:
                print "ERROR: Slab boundary condition is applied. Program is terminated"
                sys.exit()
            natms = int(line.split()[2])       # number of atoms in the SIMULATION BOX
        elif i == 3 or i == 4 or i == 5:
            boxvector.append([float(line.split()[0]), float(line.split()[1]), float(line.split()[2])])
        elif i >= 6 and (i-6) % (keytrj+2) == 0 and i <= 5 + natm_molecule*(keytrj+2):
                if line.split()[0] not in atmnam_natm_list:
                    atmnam_natm_list[line.split()[0]] = 1
                else:
                    atmnam_natm_list[line.split()[0]] += 1
        elif i >= 6 and i > 5 + natm_molecule*(keytrj+2):
            v = calvolume(imcon,boxvector[0],boxvector[1],boxvector[2])
            if v[1] == 1:
                V = v[0]
                break
            else:
                print "ERROR: unknown imcon value for calculating the volume of simulation box"
                sys.exit()

boxvector = []
################################################################
# main part of the code. calculate the RDF distribution function
with open(filedirectory + trajfilenam,'r') as f:
    for i, line in enumerate(f):
        if count <= countMax:
            if line.split()[0] == "timestep":
                boxvector = []
                natomsc = int(line.split()[2])    # number of atoms in the CONFIGURATION
                ni = i
                count += 1
                position = {}
                continue
            if ni == 0:
                continue
            elif ni > 0 and (i == ni+1 or i == ni+2):
                boxvector.append([float(line.split()[0]), float(line.split()[1]), float(line.split()[2])])
            elif ni > 0 and i == ni+3:
                # calculate the volume of simulation box. This volume is not a constant in NPT ensemble. That's why we need to
                # calculate it at ever configuration we consider.
                boxvector.append([float(line.split()[0]), float(line.split()[1]), float(line.split()[2])])
                V = calvolume(imcon,boxvector[0],boxvector[1],boxvector[2])[0]
                # get the length of each side of simulation box
                LX = sqrt(boxvector[0][0]**2+boxvector[0][1]**2+boxvector[0][2]**2)
                LY = sqrt(boxvector[1][0]**2+boxvector[1][1]**2+boxvector[1][2]**2)
                LZ = sqrt(boxvector[2][0]**2+boxvector[2][1]**2+boxvector[2][2]**2)
                dim_array = np.array([LX,LY,LZ])
            elif ni > 0 and i >= ni + 4 and (i-ni-4) % (keytrj+2) == 0 and i < ni + 3 + natomsc*(keytrj+2):    # read atom name line
                atmnam = line.split()[0]
                iatm = line.split()[1]
                weight = line.split()[2]
                charge = line.split()[3]
                if atmnam not in position:
                    position[atmnam] = []
            elif ni > 0 and i >= ni + 4 and (i-ni-4) % (keytrj+2) == 1 and i < ni + 3 + natomsc*(keytrj+2):    # read the coordinate line
                position[atmnam].append(float(line.split()[0]))
                position[atmnam].append(float(line.split()[1]))
                position[atmnam].append(float(line.split()[2]))
            elif ni > 0 and i == ni + 3 + natomsc*(keytrj+2):                                                  # reach the end of one trajectory timestep
                if (i-ni-4) % (keytrj+2) == 1:
                    position[atmnam].append(float(line.split()[0]))
                    position[atmnam].append(float(line.split()[1]))
                    position[atmnam].append(float(line.split()[2]))
                atmnam_list = list(iter(atmnam_natm_list))
                for p in range(len(atmnam_list)):
                    for q in range(p,len(atmnam_list)):
                        if atmnam_list[p]+"-"+atmnam_list[q] not in RDF:
                            RDF[atmnam_list[p]+"-"+atmnam_list[q]]=RDFhist
                        if atmnam_list[p] == atmnam_list[q]:
                            temp_name = atmnam_list[p]
                            position[temp_name] = np.array(position[temp_name])
                            natmm = atmnam_natm_list[temp_name]      # natmm is the number of atoms in one molecule.
                            RDF[temp_name + "-" + temp_name] = RDF[temp_name + "-" + temp_name] + rdf.rdfone(position[temp_name],dim_array,natmm,nHist,rHistMax,V)
                        elif atmnam_list[p] != atmnam_list[q]:
                            temp_name1 = atmnam_list[p]
                            temp_name2 = atmnam_list[q]
                            natmm1 = atmnam_natm_list[temp_name1]   # natmm1 and natmm2 are the number of two types of atoms in one molecule
                            natmm2 = atmnam_natm_list[temp_name2]
                            position[temp_name1] = np.array(position[temp_name1])
                            position[temp_name2] = np.array(position[temp_name2])
                            RDF[temp_name1 + "-" + temp_name2] = RDF[temp_name1 + "-" + temp_name2] + rdf.rdftwo(position[temp_name1],position[temp_name2],dim_array,natmm1,natmm2,nHist,rHistMax,V)
        else:
            break

with open('RDF.dat','w') as f:
    f.write(contr_header)
    f.write(strftime("%Y-%m-%d %H:%H:%S")+'\n')
    for pair in iter(RDF):
        RDF[pair] = RDF[pair]/countMax
        f.write('pair:' + pair + '\n')
        for r, g in zip(bin,RDF[pair]):
            f.write(str(r).ljust(10) + str(round(g,5)).ljust(10) + '\n')
        f.write('\n')






